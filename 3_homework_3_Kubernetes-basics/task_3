## Task 3. Solution :man_technologist:
[BASE] 2 versions of application and canary
1. Probe cluster info
```
$ k version
```
```
$ k cluster-info
```
2. Create 2 versions of application and push it to gcr repository
```
$ docker build . -f containerfile_a1 -t gcr.io/gl-bc-spring-21/demo:1.0.0
```
```
containerfile_a1

FROM busybox
CMD while true; do { echo -e "HTTP/1.1 200 OK\n\nVersion:1.0.0";  } | nc -vlp 8000; done
EXPOSE 8000
```
```
$ docker build . -f containerfile_a2 -t gcr.io/gl-bc-spring-21/demo:2.0.0
```
```
containerfile_a2

FROM busybox
CMD while true; do { echo -e "HTTP/1.1 200 OK\n\nVersion:2.0.0";  } | nc -vlp 8000; done
EXPOSE 8000
```
```
d push gcr.io/gl-bc-spring-21/demo:1.0.0
```
```
d push gcr.io/gl-bc-spring-21/demo:2.0.0
```
3. Create deploy using 2 previously created images
```
k create deploy demo-1 --image=gcr.io/gl-bc-spring-21/demo:1.0.0
```
```
k create deploy demo-2 --image=gcr.io/gl-bc-spring-21/demo:2.0.0
```
4. Get deploys, pods and logs
```
k get deploy
```
```
k get po
```
```
k logs POD_NAME
```
5. Create service LoadBalancer for demo deployment
```
k expose deploy demo-1 --type LoadBalancer --port 80 --target-port 8000
```
6. Get services
```
k get svc
```
7. Check if connection has been established
```
curl 35.226.6.88:80
```
8. Get pod's labels
```
k get po --show-labels
```
9. Set new image for pod (concrete container) and annotate that it has been happened
```
k set image deploy demo-1 demo=gcr.io/gl-bc-spring-21/demo:2.0.0 --record
```
10. Check if we changed version of app
```
curl 35.226.6.88:80
```
11. Check history deploy demo
```
k rollout history deploy demo-1
```
12. Return to revision 2
```
k rollout undo deploy demo-1 --to-revision 8
```
13. Scale deploy demo-1 to 9 replicas
```
k scale deploy demo-1 --replicas 9
```
14. Add labels to deploy demo-1 and demo-2
```
k label po --all run=demo
```
15. Add new label run=demo to service demo-1
```
k edit svc demo-1
```
16. In such scenario, only 1/10 request will come to demo-2, and 9/10 to - demo-1
```
curl 35.226.6.88:80
```
[BASE] using repo creat pod with secrets
1. Let's encrypt secrets
```
echo -n 'pass_1' | base64
```
Output
```
cGFzc18x
```
2. Let's create secret using declarative style from secret.yaml
```
---
apiVersion: v1
kind: Secret
metadata:
  name: mysecret1
type: Opaque
data:
  username: cGFzc18x
  password: Ml9wYXNz
```
```
k apply -f ./secret.yaml
```
3. Let's get created secret
```
k get secret mysecret -o wide
```
4. Let's create pod app-secret-env with 2 envs: SECRET_USERNAME, SECRET_PASSWORD applying mysecret1
```
---
apiVersion: v1
kind: Pod
metadata:
  name: app-secret-env
spec:
  containers:
  - name: mycontainer
    image: redis
    env:
      - name: SECRET_USERNAME
        valueFrom:
          secretKeyRef:
            name: mysecret1
            key: username
      - name: SECRET_PASSWORD
        valueFrom:
          secretKeyRef:
            name: mysecret1
            key: password
  restartPolicy: Never
```
```
k apply -f ./app-secret-env.yaml
```
5. Let's get created pod
```
k get pod app-secret-env
```
